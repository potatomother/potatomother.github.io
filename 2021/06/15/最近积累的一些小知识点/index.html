

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Yu Li">
  <meta name="keywords" content="">
  
  <title>最近积累的一些小知识点 - Potatomother Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>potatomother(李煜)</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于我
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                简历
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="最近积累的一些小知识点">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-06-15 15:07" pubdate>
        2021年6月15日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      8.3k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      96
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">最近积累的一些小知识点</h1>
            
            <div class="markdown-body">
              <h2 id="css"><a href="#css" class="headerlink" title="css"></a>css</h2><p><strong>1.盒子垂直水平居中的方法</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs css">//方法<span class="hljs-number">1</span><br><span class="hljs-selector-class">.parent</span>&#123;<br><br><span class="hljs-attribute">position</span>:relative;<br><br>&#125;<br><br><span class="hljs-selector-class">.child</span>&#123;<br><br><span class="hljs-attribute">position</span>:absolute;<br><br><span class="hljs-attribute">top</span>:<span class="hljs-number">50%</span>;<br><br><span class="hljs-attribute">left</span>:<span class="hljs-number">50%</span>;<br><br><span class="hljs-attribute">margin-top</span>:-<span class="hljs-number">50px</span>;<br><br><span class="hljs-attribute">margin-left</span>:-<span class="hljs-number">50px</span>;<br><br>&#125;<br><br>//方法<span class="hljs-number">2</span><br><span class="hljs-selector-class">.parent</span>&#123;<br>    <span class="hljs-attribute">position</span>:relative<br>&#125;<br><span class="hljs-selector-class">.child</span>&#123;<br>    <span class="hljs-attribute">position</span>:absolute;<br>    <span class="hljs-attribute">top</span>:<span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">left</span>:<span class="hljs-number">50%</span><br>    transform:<span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>,-<span class="hljs-number">50%</span>);<br>&#125;<br>//方法三<br><span class="hljs-attribute">display</span>：<span class="hljs-attribute">flex</span><br><br><span class="hljs-attribute">justify-content</span>：center<br><br>align-item：center<br></code></pre></td></tr></table></figure>

<p><strong>2.css 清除浮动</strong></p>
<p>方法一：在浮动的元素后增加</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;clear&quot;</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;<br>.clear&#123;<br>	clear:both;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>方法二：在包裹float的容器元素上增加 overfloat：hidden  或者 overfloat：auto</p>
<p>flex:1什么意思，三个属性是什么</p>
<p><strong>3.BFC的理解，有什么用</strong></p>
<p>Block Formatting Context 跨级格式化上下文，是一个有隔离功能的容器，里面的布局不会影响外部的元素。</p>
<p>浮动定位（绝对定位，固定定位）会触发，应用：阻止浮动元素的覆盖，左边定宽，右边自适应，下外边距折叠，清除浮动。</p>
<p><strong>4.px em rem 区别，rem怎么实现自适应</strong></p>
<p>px像素。相对屏幕分辨率说的，</p>
<p>em 相对当前对象内的文本字体大小，默认情况下1em=16px</p>
<p>rem 相对于根元素设置大小，设置 根元素的字体大小，整个的大小也对相对改变</p>
<p>cass 实现三角形</p>
<h2 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h2><p><strong>1.JS的原始类型？null是对象吗？</strong></p>
<p>js的原始类型 null undefined boolean number string symbol</p>
<p> <strong>2.对象和原始类型的不同之处？函数参数是对象会发生什么问题？</strong></p>
<p>js中除了原始类型其他的都是对象类型。对象类型和原始类型的不同之处是，原始类型中存储的数据的值，对象类型中存储的指针，通过访问指针对内存中的数据进行修改。</p>
<p>当函数参数是对象时，a赋值给b，赋的值是a中存储地址而不是真实的值。修改b的值实际是通过访问b中存储的地址修改了内存中的值，此时访问a的值还是通过a中存储的地址去访问内存中的值，这是这个值已经被b修改。</p>
<p><strong>深浅拷贝</strong></p>
<p>普通拷贝：拷贝基本类型的值，对象类型的地址</p>
<p>浅拷贝，拷贝基本类型的值，对象类型中 基本类型的值，对象类型的地址。</p>
<p>怎么实现浅拷贝？可以用     <code>Object.assign()</code>    <code>...</code></p>
<p>深拷贝，拷贝所有类型的值</p>
<p>怎么实现深拷贝？<code>JSON.parse(JSON.stringify(object))</code></p>
<p><strong>作用域 作用域链</strong></p>
<p>变量起作用的地方叫作用域一般作用域有全局作用域（var）和块级作用域（let const）。</p>
<p><strong>闭包？形成原因？ 作用？</strong></p>
<p>闭包：有权访问另一个函数作用域的函数</p>
<p>形成原因：存在上级作用域的引用</p>
<p>作用：1.保护函数的私有变量不受外部干扰2.形成不被销毁的栈内存3.将上级作用域的引用保存下来，实现方法或属性的私有化</p>
<p>典型题目</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>, i);<br>    &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>, i);<br><br></code></pre></td></tr></table></figure>

<p>原型原型链</p>
<p><strong>let var const</strong></p>
<p>var全局作用域，可以在windows访问，同时存在变量提升。</p>
<p>let 仅作用于块级作用域，有临时死区</p>
<p>const和let差不多区别是，第一次声明需要设置初始值，并且声明的原始类型不可改变，对象类型不可修改地址（地址指向的数据可以改）。</p>
<p><strong>this指向 普通函数？和箭头函数？  怎么改变普通函数里面的this指向？</strong></p>
<p>一般函数的this都指向函数的地方，如果是对象实例化的直接指向实例化的对象。</p>
<p>箭头函数本身没有this，使用的this看上级作用域</p>
<p>想修改普通函数的this指向可以通过apply call bind</p>
<p><strong>apply call bind？ 有什么区别？ apply实现bind函数？</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">fun.call(thisArg, param1, param2, ...)<br>fun.apply(thisArg, [param1,param2,...])<br>fun.bind(thisArg, param1, param2, ...)<br></code></pre></td></tr></table></figure>

<p>返回值</p>
<p>call apply返回值：fun执行的结果</p>
<p>bind返回值：fun的拷贝 </p>
<p>参数：</p>
<p><code>thisArg</code>：新的this指向</p>
<p><code>param1,param2</code>(可选): 传给<code>fun</code>的参数。</p>
<p>promise async await 区别</p>
<p>es6新特性</p>
<p>链表在js的实现，和数组的区别</p>
<p> 介绍链表 栈 队列 树的差异<br>数组增删比链表麻烦 为什么</p>
<h2 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h2><p><strong>1.vue指令</strong></p>
<p><strong>html内容绑定：</strong></p>
<p>v-model=“ vue值”</p>
<p>v-on：触发=“触发之后执行的函数”</p>
<p>​    简写 @触发=“触发之后执行的函数”</p>
<p><strong>html属性绑定</strong></p>
<p>v-bind:属性=“ vue值”      v-bind:class=“ {css样式：true  }”</p>
<p>​    简写  :属性=“ vue值”</p>
<p><strong>html插入内容</strong></p>
<p>v-html=“vue值”</p>
<p>更新元素的 <code>innerHTML</code></p>
<p>v-text=”vue值”</p>
<p>更新元素的 <code>textContent</code></p>
<p><strong>2..vue生命周期</strong></p>
<p>beforeCreated</p>
<p>created</p>
<p>beforeMounted</p>
<p>mounted</p>
<p>beforeupdated</p>
<p>updated</p>
<p>detroyed</p>
<p>beforeDestroy</p>
<p><strong>第一次加载页面的时候会触发哪些钩子函数</strong></p>
<p>beforeCreate, created, beforeMount, mounted </p>
<p><strong>在哪个钩子阶段可以操作DOM</strong>  </p>
<p>mounted</p>
<p><strong>父组件向子组件传值</strong> </p>
<p>父组件 v-bind  子组件 props 接收</p>
<p><strong>子组件向父组件传递事件</strong></p>
<p>子组件 绑定方法</p>
<p>兄弟组件之间传值</p>
<p><strong>keep-alive 怎么使用</strong></p>
<p>进行缓存，增加生命周期  activated和deactivated</p>
<p><strong>vue双向数据绑定</strong></p>
<p>object.defineProperty  （vue 2.0）和Proxy（vue3.0） 实现</p>
<p>优缺点：</p>
<p>1.object.defineProperty 劫持对象属性，Proxy劫持整个对象。</p>
<p>2.Proxy可以支持多种API，object.defineProperty 不支持数组的API</p>
<p>3.object.defineProperty需要遍历对象的每个属性</p>
<p><strong>为什么监测不到数组的变化？如何能做到proxy对低版本浏览器的兼容？</strong> </p>
<p>computed和watch之间的区别</p>
<p>性能优化</p>
<p>nextTick原理和使用场景</p>
<p>vue动态添加属性实现数据响应 v-bind</p>
<p>vue路由懒加载</p>
<p>vue封装组件</p>
<p>created 和mounted的区别  created的html节点没有渲染，mounted可以进行数据请求数据绑定，可以把数据绑定到DOM上</p>
<p>登录鉴权</p>
<p>路由守卫</p>
<p>axios怎么实现</p>
<p><strong>跨域 什么是跨域？限制了什么？不同源的话进行什么策略</strong></p>
<p>域名协议端口有一个不同就是跨域</p>
<p>浏览器会拦截跨域返回的数据</p>
<p>但有的不限制：1.scrpit标签里面的请求</p>
<p>常用的跨域方法有 JSONP，CROS，正向代理，反向代理。</p>
<p>JSONP和CROS方法需要后端服务器的配合，反向代理是在服务端建立代理给客户端发送资源。</p>
<p>jsonp nigix websocket php修改header</p>
<p>代理设置location的哪一项</p>
<p>为什么修改header就可以跨域</p>
<p><strong>什么是mock数据？</strong></p>
<p>前后端同时开发的时候，后端接口数据没有出来，前端可以mock假数据，模拟开发；</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p><strong>都有哪些排序算法？哪些是nlogn</strong></p>
<p>冒泡 选择 插入 归并 快排 堆排 希尔排序</p>
<p>nlogn ：归并 快排 堆排 希尔排序</p>
<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><p>http和https的差异 https的保密机制</p>
<p> 什么地方用对称加密 什么地方用非对称加密</p>
<p>http 三次握手四次挥手 状态码</p>
<p>CDN的实现原理， 怎么做到提速的？</p>
<p>tcp和udp<br>tcp调度算法</p>
<h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><p>完成项目的整个流程，（明确需求，实现功能，自测，他人测试，模块测试，上线，用户的体验和反馈，修改，形成一个不断更新的版本）</p>
<p><strong>从输入url到浏览器显示页面发生了什么</strong></p>
<p>1.输入网址</p>
<p>2.浏览器查找域名的IP地址（怎么查找IP）</p>
<p>3.建立TCP链接（三次握手，四次挥手，流量控制（客户端），拥塞控制（服务端））</p>
<p>4.发送HTTP请求（常见的请求方法 状态码   http2 http3 websocket）</p>
<p>5.服务端处理，返回结果</p>
<p>6.浏览器解析资源 （解析DOM生成DOM树，解析CSS生成CSS树，合并DOM树和CSS树）</p>
<p>7.浏览器布局渲染</p>
<p><strong>状态码</strong> 2xx成功 3xx重定向 4xx服务端错误 5xx客户端错误 </p>
<p>301永久重定向</p>
<p>302临时重定向</p>
<p>304：如果客户端发送了一个GET请求被允许，并且文档的内容没有改变。</p>
<p>400：客户端发出的是错误请求</p>
<p>500服务器内部错误</p>
<p>501服务器不支持客户端的请求</p>
<p><strong>拥塞控制</strong>：满开始 拥塞避免  快重传 快恢复</p>
<p><strong>http2</strong> ：一个域名使用一个TCP长连接，多路复用消除队头阻塞，二进制传输，header压缩，服务端push</p>
<p><strong>http3</strong>：基于UDP的协议，多路复用，纠错机制</p>
<p><strong>websocket</strong>：浏览器和服务器的传输协议</p>
<p><strong>为什么script会阻塞渲染</strong></p>
<p>js引擎和HTML是独立的，使用js 操作DOM的时候会引起DOM改变，会引起页面的回流和重绘</p>
<p><strong>回流</strong>：回流一定重绘，元素的位置和大小改变会引起重绘</p>
<p><strong>重绘</strong>：重绘不一定回流，元素的颜色和背景改变会引起重绘</p>
<p><strong>ansay</strong> 异步下载js，阻塞渲染，执行js</p>
<p><strong>defer</strong> 异步下载js，最后执行js</p>
<p><strong>css不阻塞DOM解析，阻塞DOM绘制</strong></p>
<p><strong>async await 如何捕获异常</strong>try catch 捕获异常</p>
<p><strong>Eventloop习题</strong></p>
<p>任务分为同步任务和异步任务，异步任务分为宏任务和微任务。</p>
<p>执行的时候 顺序 ，1.同步任务2.promise 里面的立即执行，resolve（）不会影响3.settimeout最后执行4.async 里面的resolve（）会影响执行，5.先一个宏任务然后执行所有的微任务</p>
<p>宏任务 ：setTImeout</p>
<p>微任务：promise</p>
<p><strong>缓存，具体过程</strong></p>
<p>缓存的位置有四种，1.Service Worker 2.Memory Cache3.Disk Cache 4.Push Cache 按顺序查找缓存，如果都没有命中，就会请求网络</p>
<p>Service Worker 可以自由控制缓存那些文件，如何匹配缓存，并且缓存是持续性的，如果没有命中缓存会根据优先级依次查找数据</p>
<p>Memory Cache 是内存中的缓存，读取高效，但是缓存持续时间短，会随证进程释放而释放，一旦关闭Tab页面，内存中的缓存就会释放</p>
<p>DIsk Cache是存储在硬盘中的缓存，相比于Memery Cache 胜在容量和存储时长，但读取速度相对较满。在所有的浏览器缓存中，硬盘缓存覆盖面是最大的，即使存在跨站点的情况，相同地址的资源一旦被硬盘缓存下来，就不会再次请求数据。</p>
<p>Push Cache是HTTP/2中的内容，当以上三种缓存都没有命中，才会被使用，并且缓存时间短暂，只在会话中存在，一旦会话结果就被释放。</p>
<p>网络请求，如果所有缓存都没有命中，只能发起请求来获取资源，为了性能大部分接口应该选择好的缓存策略</p>
<p><strong>缓存策略</strong>：强缓存，协商缓存。通过HTTP Header实现</p>
<p>强缓存可以设置两种HTTP Header：  Expires设置缓存过期时间 ，Cache-control设置多少秒后过期</p>
<p>协商缓存可以设置两种HTTP Header： Last-Modified（本地修改文件日期）和ETag，当浏览器发起请求验证资源时，如果没有改变，服务端返回304</p>
<p><strong>实际选择缓存策略</strong></p>
<p>对于频繁变动的资源，首先使用Cache-control：no-cache是浏览器每次请求服务器，配合ETag或者Last-Modified验证资源的有效性，可以减少每次请求资源的大小</p>
<p>代码文件，使用代码工具打包代码，对文件名进行哈希处理，当代码修改之后生成新的文件名，对代码文件设置缓存有效期一年，只有当文件名发生变化时，才会下载最新的代码文件，否则使用缓存</p>
<h2 id="css-1"><a href="#css-1" class="headerlink" title="css"></a>css</h2><p>三列布局</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span>&#123;<br>	<span class="hljs-attribute">display</span>:flex<br>	width:<span class="hljs-number">300</span><br>    .child1&#123;<br>		flex:<span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-selector-class">.child2</span>&#123;<br>		<span class="hljs-attribute">flex</span>:<span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-selector-class">.child3</span>&#123;<br>		<span class="hljs-attribute">flex</span>:<span class="hljs-number">1</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>flex:1 是flex-grow (放大)、flex-shrink（缩小）,flex-basis（元素初始大小）</p>
<p>图片设置为圆的：border-radius：50%</p>
<h2 id="vue-1"><a href="#vue-1" class="headerlink" title="vue"></a>vue</h2><p>object.definepority 为什么不支持数组</p>
<p>object.definepority 因为劫持的是对象的属性，他不支持数组的一些方法，比如.length是无法直接劫持到的，它可以劫持到每个元素，监控每个元素的变化，这样性能消耗比较明显，在vue中重写了数组的比如 sort reverse push pop shift unshift方法，监控数组的变化。</p>
<p>proxy 和object.defineprorerty对比</p>
<p>proxy劫持的是整个对象可以摆脱get set deleteProperyt（）的限制，监听数组变化更新的时候不需要遍历所有的元素。</p>
<h2 id="手写算法"><a href="#手写算法" class="headerlink" title="手写算法"></a>手写算法</h2><p>排序</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//冒泡排序</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bubbleSort</span>(<span class="hljs-params">arr</span>)</span>&#123;<br>    <span class="hljs-keyword">const</span> len=arr.length;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j=<span class="hljs-number">0</span>;j&lt;len-<span class="hljs-number">1</span>;j++)&#123;<br>            <span class="hljs-keyword">if</span>(arr[j]&gt;arr[j+<span class="hljs-number">1</span>])&#123;<br>                [arr[j],arr[j+<span class="hljs-number">1</span>]]=[arr[j+<span class="hljs-number">1</span>],arr[j]]<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//dfs</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">tree,result=[]</span>)</span>&#123;<br>    <span class="hljs-keyword">let</span> stack=[]<br>    stack.push(tree)<br>    <span class="hljs-keyword">while</span>(stack.length!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">let</span> item=stack.pop()<br>        result.push(item.name)<br>        <span class="hljs-keyword">let</span> children=item.children<br>        <span class="hljs-keyword">if</span>(children)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = children.length-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>				result.push(children[i].name)<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//防抖</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">fn,delay=<span class="hljs-number">300</span></span>)</span>&#123;<br>    <span class="hljs-keyword">let</span> timer;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">const</span> args=<span class="hljs-built_in">arguments</span>;<br>        <span class="hljs-keyword">if</span>(timer)&#123;<br>            <span class="hljs-built_in">clearTimeout</span>(timer);<br>        &#125;<br>        timer=<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>            fn.apply(<span class="hljs-built_in">this</span>,args);<br>        &#125;,delay);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//节流</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">fn,delay</span>)</span>&#123;<br>    <span class="hljs-keyword">let</span> flag=<span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">if</span>(!flag)<span class="hljs-keyword">return</span>;<br>        flag=<span class="hljs-literal">false</span>;<br>        timer=<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>            fn();<br>            flag=<span class="hljs-literal">true</span>;<br>        &#125;,delay)<br>    &#125;<br>&#125;<br><br><span class="hljs-built_in">window</span>.addEventLisenter&#123;<br>    <span class="hljs-string">&#x27;scroll&#x27;</span>,<br>        throttle(<span class="hljs-function">()=&gt;</span>&#123;<br>     	<span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)   <br>    &#125;,<span class="hljs-number">1000</span>)<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="1-HTTP和HTTPS"><a href="#1-HTTP和HTTPS" class="headerlink" title="1.HTTP和HTTPS"></a><strong>1.HTTP和HTTPS</strong></h2><p>HTTP超文本传输协议，是一个基于TCP实现的应用层协议，是一个无状态的协议。客户端和服务器之间不需要建立持久的连接，当客户端发出请求服务端返回响应，连接就被关闭了。</p>
<p>HTTP工作过程：1.地址解析URL-&gt;主机ip地址2.封装HTTP请求数据包3.封装TCP包，建立TCP连接4.客户机发送请求命令5.服务器响应6.服务器关闭TCP连接</p>
<p>HTTP请求的方法 GET POST HEAD  DELEAT</p>
<p>HTTP状态码 2xx成功 3xx重定向 4xx客户端错误 5xx服务端错误</p>
<p>HTTPS </p>
<p>HTTP+加密+认证+完整性保护=HTTPS</p>
<p>加密 TLS/SSL安全传输层协议（信息加密、完整性校验、身份验证）主要作用：</p>
<p>对数据进行加密，建立一个信息安全通道，保证传输过程中数据安全</p>
<p>对网站服务器进行真实身份认证</p>
<p>相关算法：</p>
<p>散列函数Hash，对称加密、非对称加密。利用非对称加密实现身份认证和秘钥协商，对称加密采用协商的秘钥对数据加密，基于散列函数验证信息的完整性。</p>
<p>散列函数Hash</p>
<p>常见的有DM5、SHA1、SHA256，该函数的特点是函数单向不可逆、对输入敏感、输出长度固定，对数据的任何修改都会改变散列函数的结果，用于防止信息篡改并并验证数据的完整性；在信息传输过程中，散列函数不能单独实现信息防篡改</p>
<p>身份验证CA和证书</p>
<p>只有收件人才能阅读信息，确认信息发送者的身份，保证信息在传输过程中不被篡改，发送者不能否认已经发送的信息，保证请求者与服务者的数据交换的安全性</p>
<h2 id="2-position的值relative和absolute相对于谁进行定位"><a href="#2-position的值relative和absolute相对于谁进行定位" class="headerlink" title="2.position的值relative和absolute相对于谁进行定位"></a>2.position的值relative和absolute相对于谁进行定位</h2><p>position：static（默认）relative absolute fixed</p>
<p>relative 相对于正常位置的定位，原来的位置没有脱离文档流</p>
<p>absolute 相对于离自己最近的一个不是static定位的父元素</p>
<p>fixed相对于窗口位置进行定位</p>
<h2 id="3-如何解决跨域问题"><a href="#3-如何解决跨域问题" class="headerlink" title="3.如何解决跨域问题"></a>3.如何解决跨域问题</h2><p>跨域是浏览器基于同源策略对一些数据响应的拦截，具体来说当协议端口域名存在不一致的话，浏览器会拦截响应。但是 img link 和 script标签里面的请求不拦截，</p>
<p>JSONP解决跨域问题就是把请求放在script中，这样浏览器就不会拦截。缺点：只能GET，容易XSS</p>
<p>CROS解决跨域问题是后端收到请求后再请求头上加上Access-control-allow-origin属性，浏览器判断Access-control-allow-origin中的地址是不是和当前地址相同，匹配成功就继续处理。withCrendetails属性携带cookies</p>
<p>缺点，忽略cookie，对浏览器版本有一定要求</p>
<p>代理方案：</p>
<p>正向代理：在同源的位置开一个服务，服务器和服务器之间的通信是没有跨域限制的，本地服务器收到数据之后吐给前端，解决跨域。</p>
<p>反向代理：</p>
<h2 id="4-Heap排序方法的原理？复杂度？"><a href="#4-Heap排序方法的原理？复杂度？" class="headerlink" title="4.Heap排序方法的原理？复杂度？"></a>4.Heap排序方法的原理？复杂度？</h2><p>大顶堆（父节点大于子节点）用于升序排列，小顶堆（父节点小于子节点）用于降序排列</p>
<p>1.建堆 （不满足的节点进行交换）</p>
<p>2.将根节点和最后一个元素交换</p>
<p>3.对其余元素建堆</p>
<p>建堆的时间复杂度O(N)堆调整的时间复杂度O(NlogN）</p>
<h2 id="5-几种常见的排序算法"><a href="#5-几种常见的排序算法" class="headerlink" title="5.几种常见的排序算法"></a>5.几种常见的排序算法</h2><p>​    冒泡</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bubbleSort</span>(<span class="hljs-params">arr</span>)</span>&#123;<br>    <span class="hljs-keyword">const</span> len=arr.length;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j=<span class="hljs-number">0</span>;j&lt;len-<span class="hljs-number">1</span>;j++)&#123;<br>            <span class="hljs-keyword">if</span>(arr[j]&gt;arr[j+<span class="hljs-number">1</span>])&#123;<br>                [arr[j],arr[j+<span class="hljs-number">1</span>]]=[arr[j+<span class="hljs-number">1</span>],arr[j]]<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>插入排序</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">insert</span><span class="hljs-params">(arr)</span></span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="6-数组去重"><a href="#6-数组去重" class="headerlink" title="6.数组去重"></a>6.数组去重</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js">[...new <span class="hljs-built_in">Set</span>(arr)]<br><span class="hljs-comment">//2</span><br><span class="hljs-keyword">let</span> ans=[]<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">of</span> arr)&#123;<br>    <span class="hljs-keyword">if</span>(ans.indexOf(i)==-<span class="hljs-number">1</span>)ans.push(i)<br>&#125;<br><span class="hljs-comment">//3</span><br>arr.sort(<span class="hljs-function">(<span class="hljs-params">a,b</span>)=&gt;</span>a-b)<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> arr)&#123;<br>    <span class="hljs-keyword">if</span>(arr[i]==arr[i+<span class="hljs-number">1</span>])&#123;<br>        arr.splice(i+<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)<br>    &#125;<br>&#125;<br><span class="hljs-comment">//4</span><br><span class="hljs-keyword">let</span> m=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>()<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i <span class="hljs-keyword">of</span> arr)&#123;<br>    <span class="hljs-keyword">if</span>(!m.has(i))&#123;<br>        m.set(i,<span class="hljs-number">0</span>)<br>    &#125;<br>&#125;<br>[...m.keys()]<br></code></pre></td></tr></table></figure>

<h2 id="7-如果有一个大的数组，-都是整型，-怎么找出最大的前-10-个数"><a href="#7-如果有一个大的数组，-都是整型，-怎么找出最大的前-10-个数" class="headerlink" title="7.如果有一个大的数组， 都是整型， 怎么找出最大的前 10 个数"></a>7.如果有一个大的数组， 都是整型， 怎么找出最大的前 10 个数</h2><p>sort slice(0,10)</p>
<h2 id="8-说说你对作用域链的理解"><a href="#8-说说你对作用域链的理解" class="headerlink" title="8.说说你对作用域链的理解"></a>8.说说你对作用域链的理解</h2><p>作用域：全局作用域 函数作用域 块级作用域</p>
<p>如果使用了一个变量，首先会查找当前的函数作用域或者块级作用域，如果当前作用域没有就会一层一层向上级查找，一直到全局作用域。</p>
<h2 id="9-创建ajax过程"><a href="#9-创建ajax过程" class="headerlink" title="9.创建ajax过程"></a>9.创建ajax过程</h2><p>1.创建xhr核心对象</p>
<p><code>let xhr= new XMLHttpRequest（）</code></p>
<p>2.调用open准备发送，请求方式，请求地址，同步异步</p>
<p><code>xhr.open(&#39;post&#39;,&#39;www.baidu.com/api/search&#39;,true)</code></p>
<p>3.如果是post需要设置请求头<code>xhr.setRequestHeader()</code></p>
<p>4.发送请求<code>xhr.send()</code></p>
<p>5.监听异步回调</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">xhr.onreadystatechange=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-comment">//xhr.readystate 状态码几开头</span><br>    <span class="hljs-comment">//xhr.status 状态码</span><br>    <span class="hljs-comment">//xhr.responseText返回数据</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="10渐进增强和优雅降级"><a href="#10渐进增强和优雅降级" class="headerlink" title="10渐进增强和优雅降级"></a>10渐进增强和优雅降级</h2><p>渐进增强针对低版本浏览构建最基本的功能，针对高版本的浏览器提供更好的交互和浏览效果。</p>
<p>优雅降级针对高版本的浏览器提供完整的功能，对低版本的浏览器进行兼容，保证内容也可以完整显示，保证用户体验。</p>
<h2 id="13浏览器页面有哪三层构成，分别是什么，作用是什么"><a href="#13浏览器页面有哪三层构成，分别是什么，作用是什么" class="headerlink" title="13浏览器页面有哪三层构成，分别是什么，作用是什么?"></a>13浏览器页面有哪三层构成，分别是什么，作用是什么?</h2><p>结构层、表示层、行为层</p>
<p>网页结构层是HTML或者XML之类的标记语言创建</p>
<p>网页表示层是由CSS创建，行为层</p>
<p>网页行为层负责回答内容应该如何做出反应，这是Javascript 和DOM</p>
<h2 id="15HTML5的优点与缺点"><a href="#15HTML5的优点与缺点" class="headerlink" title="15HTML5的优点与缺点"></a>15HTML5的优点与缺点</h2><p>优点：</p>
<p>1.网络标准统一，HTML5本身是由W3C推荐出来的</p>
<p>2.多设备，跨平台</p>
<p>3.及时更新</p>
<p>4.提高可用性和改进用户的友好体验</p>
<p>缺点：</p>
<p>1.安全 firefox4的web socket 和透明代理的实现存在严重的安全问题，web storage web socket很容易被黑客利用，窃取用户信息</p>
<p>2.完善性，许多特性各浏览器的支持成都也不一样。</p>
<p>3.技术门槛：HTML5简化开发者工作的同时代表了许多有新的属性和API ，比如web worker web socket web storage等特性</p>
<p>4.性能：在某些平台上的引擎问题导致HTML5性能低下。</p>
<p>5.浏览器兼容性：IE9以下几乎全军覆没</p>
<h2 id="16介绍模块化发展的认识"><a href="#16介绍模块化发展的认识" class="headerlink" title="16介绍模块化发展的认识"></a>16介绍模块化发展的认识</h2><p>将一个复杂的程序依据一定的规则封装成几个文件，并进行组合在一起</p>
<p>同时块的内部数据与实现是私有的，只是向外部暴露一些接口和方法与外部其他模块通信</p>
<p>进化过程：</p>
<p>全局function模式：将不同功能封装成不同的全局函数</p>
<p>namespace模式：简单对象封装 减少了全局变量，解决命名冲突</p>
<p>IIFE模式：匿名函数自调用（闭包） 数据是私有的，外部通过暴露的方法操作</p>
<p>IIFE模式增强 : 引入依赖  </p>
<p>优点：</p>
<p>避免命名冲突</p>
<p>更好的分离，按需加载</p>
<p>更高复用性</p>
<p>高可维护性</p>
<h2 id="17javascript垃圾回收方法"><a href="#17javascript垃圾回收方法" class="headerlink" title="17javascript垃圾回收方法"></a>17javascript垃圾回收方法</h2><p>垃圾回收基于两个原理：</p>
<ol>
<li>考虑某个变量或对象在未来的程序运行中将不会被访问</li>
<li>向这些对象要求归还内存</li>
</ol>
<p>js在找到不使用的内存主要有两种方式：引用计数和标记清除</p>
<p>引用计数：对每个对象的引用次数进行计数，如果引用次数为0则清除对象</p>
<p>​        缺点：如果两个对象互相引用（循环引用）会使得他们都不会被回收，需要手动设置为null    </p>
<p>标记清除：从全局对象开始找到所有从这个全局对象引用的对象，找引用对象引用的对象，标记对象。没有标记的对象就被清除。</p>
<p>V8垃圾回收：</p>
<p>内存分为新生代和老生代。</p>
<p>新生代（Scavenge）</p>
<p>新生代分成两部分 from to，当分配对象时先从from分配，垃圾回收时检测from空间的存活对象，存活的对象赋值到to空间，非存活的对象被释放，复制之后from和to进行交换。</p>
<p>当一个对象复制第二次还存活时，会被移动到老生代（晋升）</p>
<p>当to空间使用超过25%时，之后复制的对象直接晋升到老生代。（占比过高影响后续内存分配）</p>
<p>老生代（mark-sweep mark-compact）</p>
<p>mark-sweep标记活着的对象，清除没标记的对象</p>
<p>mark-compact标记整理，所有或者的对象移动到空间一侧，另一侧的空间回收。</p>
<p>垃圾清理的优化：</p>
<p>如果老生代活动对象过多，垃圾回收器会暂停主线程较长的时间，造成页面卡顿。</p>
<p>增量标记：将标记全堆对象拆成一个个小任务，穿插在js中。</p>
<p>懒性清理：如果当前内存足够，可以将清理过程延迟，同时垃圾回收器按需清理，不会一次性清理全部。</p>
<p>并发GC：开一个辅助线程，同时进行垃圾回收</p>
<p>并行：同时开启多个辅助线程进行垃圾回收</p>
<h2 id="18TCP-和-UDP-的区别"><a href="#18TCP-和-UDP-的区别" class="headerlink" title="18TCP 和 UDP 的区别"></a>18TCP 和 UDP 的区别</h2><p>TCP传输控制协议，UPD用户数据报协议时传输层重要的两种协议。</p>
<p>TCP是可靠的一对一的面向有连接的通信协议</p>
<p>优点是，可靠稳定，一对一通信，场景是文件传输</p>
<p>UPD是无连接的 一对多多对一的的通信协议</p>
<p>优点是，时延低实时性好，场景是直播视频聊天语音</p>
<h2 id="19性能优化"><a href="#19性能优化" class="headerlink" title="19性能优化"></a>19性能优化</h2><h2 id="20什么是Etag"><a href="#20什么是Etag" class="headerlink" title="20什么是Etag"></a>20什么是Etag</h2><p>是URL的entity tag ，用于表示URL对象是否改变，区分不同语言和session，具体内部含义是使服务器控制的，就像服务器那样。</p>
<p>客服端请求一个页面A，并在A上增加一个Etag，客户端展示页面，并将页面缓存。客户再次请求A，并将上次请求时服务器返回的Etag一起发送，服务器检查Etag，判断出该页面自上次客户端请求起没有修改，直接返回304，和一个空的响应体。</p>
<h2 id="21js继承的六种方法"><a href="#21js继承的六种方法" class="headerlink" title="21js继承的六种方法"></a>21js继承的六种方法</h2><p>原型链继承，让新实例的原型等于父类实例</p>
<p>借用构造函数继承</p>
<p>组合继承（组合原型链和构造函数继承</p>
<p>原型式继承</p>
<p>寄生式继承</p>
<p>寄生组合式继承</p>
<h2 id="23异步加载和延迟加载"><a href="#23异步加载和延迟加载" class="headerlink" title="23异步加载和延迟加载"></a>23异步加载和延迟加载</h2><p>异步加载：</p>
<p>1.在script标签上加上asnyc属性</p>
<p>2.动态插入script标签</p>
<p>3.创建并插入iframe，让他异步执行js</p>
<p>4.通过ajax获取js，通过eval执行</p>
<p>延迟加载：有些js并不是页面初始化需要的，时稍后的某些情况需要（defer）</p>
<h2 id="24-ie-各版本和-chrome-可以并行下载多少个资源"><a href="#24-ie-各版本和-chrome-可以并行下载多少个资源" class="headerlink" title="24 ie 各版本和 chrome 可以并行下载多少个资源"></a>24 ie 各版本和 chrome 可以并行下载多少个资源</h2><p>ie6 2个， ie7 4个， ie 8+  6个，firefox，chrome6个</p>
<h2 id="25Flash、-Ajax-各自的优缺点，-在使用中如何取舍？"><a href="#25Flash、-Ajax-各自的优缺点，-在使用中如何取舍？" class="headerlink" title="25Flash、 Ajax 各自的优缺点， 在使用中如何取舍？"></a>25Flash、 Ajax 各自的优缺点， 在使用中如何取舍？</h2><p>flash 适合处理多媒体、矢量图形、访问机器，对CSS、处理文本上不足，不容易被搜索</p>
<p>ajax对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足</p>
<h2 id="26快排"><a href="#26快排" class="headerlink" title="26快排"></a>26快排</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//快速排序</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">quickSort</span>(<span class="hljs-params">arr</span>)</span>&#123;<br>	<span class="hljs-keyword">if</span>(arr.length&lt;<span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br>    <span class="hljs-keyword">var</span> left=[],right=[],current=arr.splice(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;arr.length;i++)&#123;<br>        <span class="hljs-keyword">if</span>(curent&lt;arr[i])right.push(arr[i])<br>        <span class="hljs-keyword">else</span> left.push(arr[i])<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> quickSort(left).concat(current,quickSort(right))<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="28es6"><a href="#28es6" class="headerlink" title="28es6"></a>28es6</h2><h2 id="29js继承方式及其优缺点"><a href="#29js继承方式及其优缺点" class="headerlink" title="29js继承方式及其优缺点"></a>29js继承方式及其优缺点</h2><p>原型链继承：child.prototype=new parent() child.prototype.constructor=chlid 新实例的原型等于父类的实例，缺点：新实例无法向父类构造函数传参，继承单一，所有新实例都会共享父类实例的属性</p>
<p>构造函数继承：parent.call(this,name)用.call和.apply将父类构造函数引入子类。缺点：不能复用，不能继承父类原型上的方法</p>
<p>组合继承：使用原型链和构造函数两种方式继承，优点：可以像父类构造函数传参，可以复用父类原型方法，不共享父类的引用属性 。缺点：调用了两次父类的构造方法，存在一份多余的父类实例属性</p>
<p>组合继承优化：Child.prototype=parent.prototype 优点：可以向父类构造函数传参，可以复用父类原型方法 缺点：当修复子类构造函数的指向之后，父类实例的构造函数的指向也会改变</p>
<p>组合继承优化2 寄生组合继承：child.prototype=Object.creat(Parent.prototype)</p>
<p>原型式继承 let instance=new parent() 缺点：属性被实例共享</p>
<p>寄生式继承： Object.creat(Parent.prototype) </p>
<h2 id="30Http2-0"><a href="#30Http2-0" class="headerlink" title="30Http2.0"></a>30Http2.0</h2><p>使用了二进制传输，多路复用的技术解决HTTP的队头阻塞问题，对Header进行压缩，服务端主动推送。</p>
<p>一般说一个域名使用一个TCP连接，但是如果连接中出现丢包，多路复用使得的HTTP2的表现不如HTTP1</p>
<h2 id="31-defer和async"><a href="#31-defer和async" class="headerlink" title="31 defer和async"></a>31 defer和async</h2><p>在script中可以加上defer（延迟）和async（异步），defer异步下载js，在浏览器解析完DOM和CSS之后，<code>DOMContentLoaded</code> 事件触发之前完成，解析js，async异步下载和解析js</p>
<h2 id="32浮动和浮动清除"><a href="#32浮动和浮动清除" class="headerlink" title="32浮动和浮动清除"></a>32浮动和浮动清除</h2><p>浮动：使元素脱离文档流进行浮动，在页面中不占位置</p>
<p>为什么清楚浮动：阻止浮动元素的覆盖，父级元素塌陷</p>
<p>清除浮动：1.在浮动标签后面添加一个标签，设置为clear：both</p>
<p>2.给浮动元素的容器添加浮动</p>
<p>3.给父标签设置overflow：hidden</p>
<p>4.伪元素清除浮动 :after clear:both</p>
<h2 id="34设计模式"><a href="#34设计模式" class="headerlink" title="34设计模式"></a>34设计模式</h2><h2 id="35说说你对闭包的理解"><a href="#35说说你对闭包的理解" class="headerlink" title="35说说你对闭包的理解"></a>35说说你对闭包的理解</h2><p>一个函数内部定义了一个函数，内部的函数可以访问外部函数的变量。优点：可以避免变量污染 缺点：常驻内存，容易造成内存泄漏</p>
<p>原型链 this指向</p>
<h2 id="36请你谈谈-Cookie-的弊端"><a href="#36请你谈谈-Cookie-的弊端" class="headerlink" title="36请你谈谈 Cookie 的弊端"></a>36请你谈谈 Cookie 的弊端</h2><p>每一个域名下最多生成20个cookies，每个cookies最多长4kb</p>
<p>安全问题，如果cookies被人拦截就会取得session信息</p>
<p>所以 登录信息等重要信息放在session中，其他信息可以放在cookies中</p>
<h2 id="37浏览器本地存储"><a href="#37浏览器本地存储" class="headerlink" title="37浏览器本地存储"></a>37浏览器本地存储</h2><p>web storage 包括 localStorage 和 sessionStorage ，sessionStorage当关闭一个会话窗口之后sessionStorage也会销毁，sessionStorage存在服务器中，会占用服务器的一定空间。</p>
<p>LocalStorage如果不主动删除，数据永远不会过期</p>
<p>indexDB 浏览器本地数据库，除非被清理否则一直存在</p>
<p>Service Worker是运行在浏览器背后的独立线程，一般可以用来实现缓存存功能，如果使用servise worker 传输协议必须是HTTPS</p>
<h2 id="38web-storage-和-cookie-的区别"><a href="#38web-storage-和-cookie-的区别" class="headerlink" title="38web storage 和 cookie 的区别"></a>38web storage 和 cookie 的区别</h2><p>1.cookies的数据会在服务器和浏览器中来回传递，web storage 不予服务器发生交互</p>
<p>2.cookies4KB，web storage的存储容量更大5M，</p>
<p>3.cookies需要指定作用域，web storage可以跨域调用</p>
<p>4.cookies可以在过期之前都有效，localStorage如果该不删除会一直存在，sessionStorage会存在于当前会话中</p>
<p>5.cookies 需要自己封装接口，web storage有一些线程的方法可以调用</p>
<h2 id="39cookie-和-session-的区别："><a href="#39cookie-和-session-的区别：" class="headerlink" title="39cookie 和 session 的区别："></a>39cookie 和 session 的区别：</h2><ol>
<li>cookie数据存放在客户的浏览器（客户端）上，session数据放在服务器上，但是服务端的session的实现对客户端的cookie有依赖关系的；</li>
<li>cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用session；</li>
<li>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能。考虑到减轻服务器性能方面，应当使用COOKIE；</li>
<li>单个cookie在客户端的限制是4K，就是说一个站点在客户端存放的COOKIE不能超过4K；</li>
</ol>
<h2 id="40-display-none-和-visibility-hidden-的区别？"><a href="#40-display-none-和-visibility-hidden-的区别？" class="headerlink" title="40.display:none 和 visibility:hidden 的区别？"></a>40.display:none 和 visibility:hidden 的区别？</h2><p>display:none隐藏后不占据额外空间，它会产生回流和重绘，而visibility:hidden和opacity:0元素虽然隐藏了，但它们仍然占据着空间，它们俩只会引起页面重绘。</p>
<h2 id="46-CSS3-新增伪类有那些？"><a href="#46-CSS3-新增伪类有那些？" class="headerlink" title="46.CSS3 新增伪类有那些？"></a>46.CSS3 新增伪类有那些？</h2><p>:first-child :last-child :nth-child :first-of -type :last -of -type :only-of-type :only-child</p>
<p>表单 :enabled  :disabled  :checked </p>
<h2 id="47-CSS3-有哪些新特性？"><a href="#47-CSS3-有哪些新特性？" class="headerlink" title="47.CSS3 有哪些新特性？"></a>47.CSS3 有哪些新特性？</h2><p>新增选择器 p:nth-child（n）{color: rgba（255, 0, 0, 0.75）}</p>
<p>弹性盒模型 display: flex;</p>
<p>多列布局 column-count: 5;</p>
<p>媒体查询 @media （max-width: 480px） {.box: {column-count: 1;}}</p>
<p>个性化字体 @font-face{font-family:BorderWeb;src:url（BORDERW0.eot）；}</p>
<p>颜色透明度 color: rgba（255, 0, 0, 0.75）；</p>
<p>圆角 border-radius: 5px;</p>
<p>渐变 background:linear-gradient（red, green, blue）；</p>
<p>阴影 box-shadow:3px 3px 3px rgba（0, 64, 128, 0.3）；</p>
<p>倒影 box-reflect: below 2px;</p>
<p>文字装饰 text-stroke-color: red;</p>
<p>文字溢出 text-overflow:ellipsis;</p>
<p>背景效果 background-size: 100px 100px;</p>
<p>边框效果 border-image:url（bt_blue.png） 0 10;</p>
<p><strong>转换</strong></p>
<p>旋转 transform: rotate（20deg）；</p>
<p>倾斜 transform: skew（150deg, -10deg）；</p>
<p>位移 transform:translate（20px, 20px）；</p>
<p>缩放 transform: scale（.5）；</p>
<p>平滑过渡 transition: all .3s ease-in .1s;</p>
<p>动画 @keyframes anim-1 {50% {border-radius: 50%;}} animation: anim-1 1s;</p>
<h2 id="48-BFC-块级格式上下文"><a href="#48-BFC-块级格式上下文" class="headerlink" title="48.BFC 块级格式上下文"></a><strong>48.BFC 块级格式上下文</strong></h2><p>是一个具有隔离功能的容器，里面的布局不会影响外面的元素</p>
<p>触发：1.float不为none 2.overflow不是visable 3.display是inline-block，table-cell 4.position为table-caption 绝对定位或固定定位4.根元素</p>
<p>作用：自适应两栏布局（左边定宽，右边自适应）、清除内部浮动、阻止浮动元素的覆盖、</p>
<h2 id="49语义化标签"><a href="#49语义化标签" class="headerlink" title="49语义化标签"></a>49<strong>语义化标签</strong></h2><p>header nav main artical aside footer section</p>
<p>代码结构清晰，有利于开发和维护</p>
<p>方便其他设备解析，根据语意渲染网页</p>
<p>有利于搜索引擎优化，爬虫会根据不同的标签赋予不同的权重</p>
<h2 id="50-Doctype-作用-严格模式与混杂模式如何区分？-它们有何意义"><a href="#50-Doctype-作用-严格模式与混杂模式如何区分？-它们有何意义" class="headerlink" title="50 Doctype 作用? 严格模式与混杂模式如何区分？ 它们有何意义?"></a>50 Doctype 作用? 严格模式与混杂模式如何区分？ 它们有何意义?</h2><p><code>&lt;!DOCTYPE&gt;</code>声明叫做文件类型定义（DTD），声明的作用为了告诉浏览器该文件的类型。让浏览器解析器知道应该用哪个规范来解析文档。&lt;!DOCTYPE&gt;声明必须在 HTML 文档的第一行，这并不是一个 HTML 标签。</p>
<p><strong>严格模式：</strong>又称标准模式，是指浏览器按照 W3C 标准解析代码。</p>
<p><strong>混杂模式：</strong>又称怪异模式或兼容模式，是指浏览器用自己的方式解析代码。页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。</p>
<p><strong>HTML5 没有严格和混杂之分</strong><!DOCTYPE html></p>
<h2 id="51你知道多少种-Doctype-文档类型"><a href="#51你知道多少种-Doctype-文档类型" class="headerlink" title="51你知道多少种 Doctype 文档类型"></a>51你知道多少种 Doctype 文档类型</h2><p>表示严格版本、过渡版本以及基于框架的 HTML 文档。</p>
<h2 id="52-HTML-与-XHTML——二者有什么区别"><a href="#52-HTML-与-XHTML——二者有什么区别" class="headerlink" title="52.HTML 与 XHTML——二者有什么区别"></a>52.HTML 与 XHTML——二者有什么区别</h2><p>XHTML可以兼容各大浏览器，手机以及PDA，浏览器能够快速正确地编译网页，XHTML语法较为严谨</p>
<p>a.XHTML 元素必须被正确地嵌套<br>b. XHTML 元素必须被关闭<br>c. 标签名必须用小写字母<br>d. XHTML 文档必须拥有根元素</p>
<h2 id="53，-常见兼容性问题？"><a href="#53，-常见兼容性问题？" class="headerlink" title="53， 常见兼容性问题？"></a>53， 常见兼容性问题？</h2><h2 id="54DOM-操作——怎样添加、-移除、-移动、-复制、-创建和查找节点"><a href="#54DOM-操作——怎样添加、-移除、-移动、-复制、-创建和查找节点" class="headerlink" title="54DOM 操作——怎样添加、 移除、 移动、 复制、 创建和查找节点"></a>54DOM 操作——怎样添加、 移除、 移动、 复制、 创建和查找节点</h2><p>1）创建新节点</p>
<p>   createDocumentFragment()  //创建一个DOM片段</p>
<p>   createElement()  //创建一个具体的元素</p>
<p>   createTextNode()  //创建一个文本节点</p>
<p>（2）添加、移除、替换、插入</p>
<p>   appendChild()</p>
<p>   removeChild()</p>
<p>   replaceChild()</p>
<p>   insertBefore()</p>
<p>（3）查找</p>
<p>   getElementsByTagName()  //通过标签名称</p>
<p>   getElementsByName()  //通过元素的Name属性的值</p>
<p>   getElementById()  //通过元素Id，唯一性</p>
<p>（4）复制 ul.cloneNode(true); //深复制  ul.cloneNode(false); //浅复制</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/CSS-JavaScript-Vue/">CSS JavaScript Vue</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/06/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">计算机网络知识点</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/06/15/%E8%A7%A3%E5%86%B3GitHub%E5%AE%98%E7%BD%91%E6%89%93%E4%B8%8D%E5%BC%80%E9%97%AE%E9%A2%98/">
                        <span class="hidden-mobile">解决GitHub官网打不开问题</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <div>李煜</div> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>












  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
